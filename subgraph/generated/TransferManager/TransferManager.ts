// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class AddedToWhitelist extends ethereum.Event {
  get params(): AddedToWhitelist__Params {
    return new AddedToWhitelist__Params(this);
  }
}

export class AddedToWhitelist__Params {
  _event: AddedToWhitelist;

  constructor(event: AddedToWhitelist) {
    this._event = event;
  }

  get wallet(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get target(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get whitelistAfter(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class RemovedFromWhitelist extends ethereum.Event {
  get params(): RemovedFromWhitelist__Params {
    return new RemovedFromWhitelist__Params(this);
  }
}

export class RemovedFromWhitelist__Params {
  _event: RemovedFromWhitelist;

  constructor(event: RemovedFromWhitelist) {
    this._event = event;
  }

  get wallet(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get target(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class PendingTransferCreated extends ethereum.Event {
  get params(): PendingTransferCreated__Params {
    return new PendingTransferCreated__Params(this);
  }
}

export class PendingTransferCreated__Params {
  _event: PendingTransferCreated;

  constructor(event: PendingTransferCreated) {
    this._event = event;
  }

  get wallet(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get id(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get executeAfter(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get token(): Address {
    return this._event.parameters[3].value.toAddress();
  }

  get to(): Address {
    return this._event.parameters[4].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }

  get data(): Bytes {
    return this._event.parameters[6].value.toBytes();
  }
}

export class PendingTransferExecuted extends ethereum.Event {
  get params(): PendingTransferExecuted__Params {
    return new PendingTransferExecuted__Params(this);
  }
}

export class PendingTransferExecuted__Params {
  _event: PendingTransferExecuted;

  constructor(event: PendingTransferExecuted) {
    this._event = event;
  }

  get wallet(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get id(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }
}

export class PendingTransferCanceled extends ethereum.Event {
  get params(): PendingTransferCanceled__Params {
    return new PendingTransferCanceled__Params(this);
  }
}

export class PendingTransferCanceled__Params {
  _event: PendingTransferCanceled;

  constructor(event: PendingTransferCanceled) {
    this._event = event;
  }

  get wallet(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get id(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }
}

export class LimitChanged extends ethereum.Event {
  get params(): LimitChanged__Params {
    return new LimitChanged__Params(this);
  }
}

export class LimitChanged__Params {
  _event: LimitChanged;

  constructor(event: LimitChanged) {
    this._event = event;
  }

  get wallet(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newLimit(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get startAfter(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Transfer extends ethereum.Event {
  get params(): Transfer__Params {
    return new Transfer__Params(this);
  }
}

export class Transfer__Params {
  _event: Transfer;

  constructor(event: Transfer) {
    this._event = event;
  }

  get wallet(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get token(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get to(): Address {
    return this._event.parameters[3].value.toAddress();
  }

  get data(): Bytes {
    return this._event.parameters[4].value.toBytes();
  }
}

export class Approved extends ethereum.Event {
  get params(): Approved__Params {
    return new Approved__Params(this);
  }
}

export class Approved__Params {
  _event: Approved;

  constructor(event: Approved) {
    this._event = event;
  }

  get wallet(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get token(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get spender(): Address {
    return this._event.parameters[3].value.toAddress();
  }
}

export class CalledContract extends ethereum.Event {
  get params(): CalledContract__Params {
    return new CalledContract__Params(this);
  }
}

export class CalledContract__Params {
  _event: CalledContract;

  constructor(event: CalledContract) {
    this._event = event;
  }

  get wallet(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get to(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get data(): Bytes {
    return this._event.parameters[3].value.toBytes();
  }
}

export class ApprovedAndCalledContract extends ethereum.Event {
  get params(): ApprovedAndCalledContract__Params {
    return new ApprovedAndCalledContract__Params(this);
  }
}

export class ApprovedAndCalledContract__Params {
  _event: ApprovedAndCalledContract;

  constructor(event: ApprovedAndCalledContract) {
    this._event = event;
  }

  get wallet(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get to(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get spender(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get token(): Address {
    return this._event.parameters[3].value.toAddress();
  }

  get amountApproved(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }

  get amountSpent(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }

  get data(): Bytes {
    return this._event.parameters[6].value.toBytes();
  }
}

export class TransactionExecuted extends ethereum.Event {
  get params(): TransactionExecuted__Params {
    return new TransactionExecuted__Params(this);
  }
}

export class TransactionExecuted__Params {
  _event: TransactionExecuted;

  constructor(event: TransactionExecuted) {
    this._event = event;
  }

  get wallet(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get success(): boolean {
    return this._event.parameters[1].value.toBoolean();
  }

  get signedHash(): Bytes {
    return this._event.parameters[2].value.toBytes();
  }
}

export class ModuleCreated extends ethereum.Event {
  get params(): ModuleCreated__Params {
    return new ModuleCreated__Params(this);
  }
}

export class ModuleCreated__Params {
  _event: ModuleCreated;

  constructor(event: ModuleCreated) {
    this._event = event;
  }

  get name(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }
}

export class ModuleInitialised extends ethereum.Event {
  get params(): ModuleInitialised__Params {
    return new ModuleInitialised__Params(this);
  }
}

export class ModuleInitialised__Params {
  _event: ModuleInitialised;

  constructor(event: ModuleInitialised) {
    this._event = event;
  }

  get wallet(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class TransferManager__getDailyUnspentResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class TransferManager__getPendingLimitResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class TransferManager extends ethereum.SmartContract {
  static bind(address: Address): TransferManager {
    return new TransferManager("TransferManager", address);
  }

  securityWindow(): BigInt {
    let result = super.call("securityWindow", "securityWindow():(uint256)", []);

    return result[0].toBigInt();
  }

  try_securityWindow(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "securityWindow",
      "securityWindow():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  isValidSignature(_msgHash: Bytes, _signature: Bytes): Bytes {
    let result = super.call(
      "isValidSignature",
      "isValidSignature(bytes32,bytes):(bytes4)",
      [
        ethereum.Value.fromFixedBytes(_msgHash),
        ethereum.Value.fromBytes(_signature)
      ]
    );

    return result[0].toBytes();
  }

  try_isValidSignature(
    _msgHash: Bytes,
    _signature: Bytes
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "isValidSignature",
      "isValidSignature(bytes32,bytes):(bytes4)",
      [
        ethereum.Value.fromFixedBytes(_msgHash),
        ethereum.Value.fromBytes(_signature)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  isValidSignature1(_data: Bytes, _signature: Bytes): Bytes {
    let result = super.call(
      "isValidSignature",
      "isValidSignature(bytes,bytes):(bytes4)",
      [ethereum.Value.fromBytes(_data), ethereum.Value.fromBytes(_signature)]
    );

    return result[0].toBytes();
  }

  try_isValidSignature1(
    _data: Bytes,
    _signature: Bytes
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "isValidSignature",
      "isValidSignature(bytes,bytes):(bytes4)",
      [ethereum.Value.fromBytes(_data), ethereum.Value.fromBytes(_signature)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  getNonce(_wallet: Address): BigInt {
    let result = super.call("getNonce", "getNonce(address):(uint256)", [
      ethereum.Value.fromAddress(_wallet)
    ]);

    return result[0].toBigInt();
  }

  try_getNonce(_wallet: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("getNonce", "getNonce(address):(uint256)", [
      ethereum.Value.fromAddress(_wallet)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getCurrentLimit(_wallet: Address): BigInt {
    let result = super.call(
      "getCurrentLimit",
      "getCurrentLimit(address):(uint256)",
      [ethereum.Value.fromAddress(_wallet)]
    );

    return result[0].toBigInt();
  }

  try_getCurrentLimit(_wallet: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getCurrentLimit",
      "getCurrentLimit(address):(uint256)",
      [ethereum.Value.fromAddress(_wallet)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getDailyUnspent(_wallet: Address): TransferManager__getDailyUnspentResult {
    let result = super.call(
      "getDailyUnspent",
      "getDailyUnspent(address):(uint256,uint64)",
      [ethereum.Value.fromAddress(_wallet)]
    );

    return new TransferManager__getDailyUnspentResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_getDailyUnspent(
    _wallet: Address
  ): ethereum.CallResult<TransferManager__getDailyUnspentResult> {
    let result = super.tryCall(
      "getDailyUnspent",
      "getDailyUnspent(address):(uint256,uint64)",
      [ethereum.Value.fromAddress(_wallet)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new TransferManager__getDailyUnspentResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  securityPeriod(): BigInt {
    let result = super.call("securityPeriod", "securityPeriod():(uint256)", []);

    return result[0].toBigInt();
  }

  try_securityPeriod(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "securityPeriod",
      "securityPeriod():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  oldLimitManager(): Address {
    let result = super.call(
      "oldLimitManager",
      "oldLimitManager():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_oldLimitManager(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "oldLimitManager",
      "oldLimitManager():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  transferStorage(): Address {
    let result = super.call(
      "transferStorage",
      "transferStorage():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_transferStorage(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "transferStorage",
      "transferStorage():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getPendingLimit(_wallet: Address): TransferManager__getPendingLimitResult {
    let result = super.call(
      "getPendingLimit",
      "getPendingLimit(address):(uint256,uint64)",
      [ethereum.Value.fromAddress(_wallet)]
    );

    return new TransferManager__getPendingLimitResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_getPendingLimit(
    _wallet: Address
  ): ethereum.CallResult<TransferManager__getPendingLimitResult> {
    let result = super.tryCall(
      "getPendingLimit",
      "getPendingLimit(address):(uint256,uint64)",
      [ethereum.Value.fromAddress(_wallet)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new TransferManager__getPendingLimitResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  execute(
    _wallet: Address,
    _data: Bytes,
    _nonce: BigInt,
    _signatures: Bytes,
    _gasPrice: BigInt,
    _gasLimit: BigInt
  ): boolean {
    let result = super.call(
      "execute",
      "execute(address,bytes,uint256,bytes,uint256,uint256):(bool)",
      [
        ethereum.Value.fromAddress(_wallet),
        ethereum.Value.fromBytes(_data),
        ethereum.Value.fromUnsignedBigInt(_nonce),
        ethereum.Value.fromBytes(_signatures),
        ethereum.Value.fromUnsignedBigInt(_gasPrice),
        ethereum.Value.fromUnsignedBigInt(_gasLimit)
      ]
    );

    return result[0].toBoolean();
  }

  try_execute(
    _wallet: Address,
    _data: Bytes,
    _nonce: BigInt,
    _signatures: Bytes,
    _gasPrice: BigInt,
    _gasLimit: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "execute",
      "execute(address,bytes,uint256,bytes,uint256,uint256):(bool)",
      [
        ethereum.Value.fromAddress(_wallet),
        ethereum.Value.fromBytes(_data),
        ethereum.Value.fromUnsignedBigInt(_nonce),
        ethereum.Value.fromBytes(_signatures),
        ethereum.Value.fromUnsignedBigInt(_gasPrice),
        ethereum.Value.fromUnsignedBigInt(_gasLimit)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isWhitelisted(_wallet: Address, _target: Address): boolean {
    let result = super.call(
      "isWhitelisted",
      "isWhitelisted(address,address):(bool)",
      [ethereum.Value.fromAddress(_wallet), ethereum.Value.fromAddress(_target)]
    );

    return result[0].toBoolean();
  }

  try_isWhitelisted(
    _wallet: Address,
    _target: Address
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isWhitelisted",
      "isWhitelisted(address,address):(bool)",
      [ethereum.Value.fromAddress(_wallet), ethereum.Value.fromAddress(_target)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  priceProvider(): Address {
    let result = super.call("priceProvider", "priceProvider():(address)", []);

    return result[0].toAddress();
  }

  try_priceProvider(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "priceProvider",
      "priceProvider():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  relayer(param0: Address): BigInt {
    let result = super.call("relayer", "relayer(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBigInt();
  }

  try_relayer(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("relayer", "relayer(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  isOnlyOwnerModule(): Bytes {
    let result = super.call(
      "isOnlyOwnerModule",
      "isOnlyOwnerModule():(bytes4)",
      []
    );

    return result[0].toBytes();
  }

  try_isOnlyOwnerModule(): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "isOnlyOwnerModule",
      "isOnlyOwnerModule():(bytes4)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  getPendingTransfer(_wallet: Address, _id: Bytes): BigInt {
    let result = super.call(
      "getPendingTransfer",
      "getPendingTransfer(address,bytes32):(uint64)",
      [ethereum.Value.fromAddress(_wallet), ethereum.Value.fromFixedBytes(_id)]
    );

    return result[0].toBigInt();
  }

  try_getPendingTransfer(
    _wallet: Address,
    _id: Bytes
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getPendingTransfer",
      "getPendingTransfer(address,bytes32):(uint64)",
      [ethereum.Value.fromAddress(_wallet), ethereum.Value.fromFixedBytes(_id)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  defaultLimit(): BigInt {
    let result = super.call("defaultLimit", "defaultLimit():(uint256)", []);

    return result[0].toBigInt();
  }

  try_defaultLimit(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("defaultLimit", "defaultLimit():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  isLimitDisabled(_wallet: Address): boolean {
    let result = super.call(
      "isLimitDisabled",
      "isLimitDisabled(address):(bool)",
      [ethereum.Value.fromAddress(_wallet)]
    );

    return result[0].toBoolean();
  }

  try_isLimitDisabled(_wallet: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isLimitDisabled",
      "isLimitDisabled(address):(bool)",
      [ethereum.Value.fromAddress(_wallet)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }
}

export class ApproveTokenCall extends ethereum.Call {
  get inputs(): ApproveTokenCall__Inputs {
    return new ApproveTokenCall__Inputs(this);
  }

  get outputs(): ApproveTokenCall__Outputs {
    return new ApproveTokenCall__Outputs(this);
  }
}

export class ApproveTokenCall__Inputs {
  _call: ApproveTokenCall;

  constructor(call: ApproveTokenCall) {
    this._call = call;
  }

  get _wallet(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _token(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _spender(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get _amount(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class ApproveTokenCall__Outputs {
  _call: ApproveTokenCall;

  constructor(call: ApproveTokenCall) {
    this._call = call;
  }
}

export class InitCall extends ethereum.Call {
  get inputs(): InitCall__Inputs {
    return new InitCall__Inputs(this);
  }

  get outputs(): InitCall__Outputs {
    return new InitCall__Outputs(this);
  }
}

export class InitCall__Inputs {
  _call: InitCall;

  constructor(call: InitCall) {
    this._call = call;
  }

  get _wallet(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class InitCall__Outputs {
  _call: InitCall;

  constructor(call: InitCall) {
    this._call = call;
  }
}

export class TransferTokenCall extends ethereum.Call {
  get inputs(): TransferTokenCall__Inputs {
    return new TransferTokenCall__Inputs(this);
  }

  get outputs(): TransferTokenCall__Outputs {
    return new TransferTokenCall__Outputs(this);
  }
}

export class TransferTokenCall__Inputs {
  _call: TransferTokenCall;

  constructor(call: TransferTokenCall) {
    this._call = call;
  }

  get _wallet(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _token(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _to(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get _amount(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get _data(): Bytes {
    return this._call.inputValues[4].value.toBytes();
  }
}

export class TransferTokenCall__Outputs {
  _call: TransferTokenCall;

  constructor(call: TransferTokenCall) {
    this._call = call;
  }
}

export class AddToWhitelistCall extends ethereum.Call {
  get inputs(): AddToWhitelistCall__Inputs {
    return new AddToWhitelistCall__Inputs(this);
  }

  get outputs(): AddToWhitelistCall__Outputs {
    return new AddToWhitelistCall__Outputs(this);
  }
}

export class AddToWhitelistCall__Inputs {
  _call: AddToWhitelistCall;

  constructor(call: AddToWhitelistCall) {
    this._call = call;
  }

  get _wallet(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _target(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class AddToWhitelistCall__Outputs {
  _call: AddToWhitelistCall;

  constructor(call: AddToWhitelistCall) {
    this._call = call;
  }
}

export class AddModuleCall extends ethereum.Call {
  get inputs(): AddModuleCall__Inputs {
    return new AddModuleCall__Inputs(this);
  }

  get outputs(): AddModuleCall__Outputs {
    return new AddModuleCall__Outputs(this);
  }
}

export class AddModuleCall__Inputs {
  _call: AddModuleCall;

  constructor(call: AddModuleCall) {
    this._call = call;
  }

  get _wallet(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _module(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class AddModuleCall__Outputs {
  _call: AddModuleCall;

  constructor(call: AddModuleCall) {
    this._call = call;
  }
}

export class ExecutePendingTransferCall extends ethereum.Call {
  get inputs(): ExecutePendingTransferCall__Inputs {
    return new ExecutePendingTransferCall__Inputs(this);
  }

  get outputs(): ExecutePendingTransferCall__Outputs {
    return new ExecutePendingTransferCall__Outputs(this);
  }
}

export class ExecutePendingTransferCall__Inputs {
  _call: ExecutePendingTransferCall;

  constructor(call: ExecutePendingTransferCall) {
    this._call = call;
  }

  get _wallet(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _token(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _to(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get _amount(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get _data(): Bytes {
    return this._call.inputValues[4].value.toBytes();
  }

  get _block(): BigInt {
    return this._call.inputValues[5].value.toBigInt();
  }
}

export class ExecutePendingTransferCall__Outputs {
  _call: ExecutePendingTransferCall;

  constructor(call: ExecutePendingTransferCall) {
    this._call = call;
  }
}

export class RecoverTokenCall extends ethereum.Call {
  get inputs(): RecoverTokenCall__Inputs {
    return new RecoverTokenCall__Inputs(this);
  }

  get outputs(): RecoverTokenCall__Outputs {
    return new RecoverTokenCall__Outputs(this);
  }
}

export class RecoverTokenCall__Inputs {
  _call: RecoverTokenCall;

  constructor(call: RecoverTokenCall) {
    this._call = call;
  }

  get _token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class RecoverTokenCall__Outputs {
  _call: RecoverTokenCall;

  constructor(call: RecoverTokenCall) {
    this._call = call;
  }
}

export class DisableLimitCall extends ethereum.Call {
  get inputs(): DisableLimitCall__Inputs {
    return new DisableLimitCall__Inputs(this);
  }

  get outputs(): DisableLimitCall__Outputs {
    return new DisableLimitCall__Outputs(this);
  }
}

export class DisableLimitCall__Inputs {
  _call: DisableLimitCall;

  constructor(call: DisableLimitCall) {
    this._call = call;
  }

  get _wallet(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class DisableLimitCall__Outputs {
  _call: DisableLimitCall;

  constructor(call: DisableLimitCall) {
    this._call = call;
  }
}

export class ExecuteCall extends ethereum.Call {
  get inputs(): ExecuteCall__Inputs {
    return new ExecuteCall__Inputs(this);
  }

  get outputs(): ExecuteCall__Outputs {
    return new ExecuteCall__Outputs(this);
  }
}

export class ExecuteCall__Inputs {
  _call: ExecuteCall;

  constructor(call: ExecuteCall) {
    this._call = call;
  }

  get _wallet(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _data(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get _nonce(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get _signatures(): Bytes {
    return this._call.inputValues[3].value.toBytes();
  }

  get _gasPrice(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }

  get _gasLimit(): BigInt {
    return this._call.inputValues[5].value.toBigInt();
  }
}

export class ExecuteCall__Outputs {
  _call: ExecuteCall;

  constructor(call: ExecuteCall) {
    this._call = call;
  }

  get success(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class ChangeLimitCall extends ethereum.Call {
  get inputs(): ChangeLimitCall__Inputs {
    return new ChangeLimitCall__Inputs(this);
  }

  get outputs(): ChangeLimitCall__Outputs {
    return new ChangeLimitCall__Outputs(this);
  }
}

export class ChangeLimitCall__Inputs {
  _call: ChangeLimitCall;

  constructor(call: ChangeLimitCall) {
    this._call = call;
  }

  get _wallet(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _newLimit(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class ChangeLimitCall__Outputs {
  _call: ChangeLimitCall;

  constructor(call: ChangeLimitCall) {
    this._call = call;
  }
}

export class CancelPendingTransferCall extends ethereum.Call {
  get inputs(): CancelPendingTransferCall__Inputs {
    return new CancelPendingTransferCall__Inputs(this);
  }

  get outputs(): CancelPendingTransferCall__Outputs {
    return new CancelPendingTransferCall__Outputs(this);
  }
}

export class CancelPendingTransferCall__Inputs {
  _call: CancelPendingTransferCall;

  constructor(call: CancelPendingTransferCall) {
    this._call = call;
  }

  get _wallet(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _id(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }
}

export class CancelPendingTransferCall__Outputs {
  _call: CancelPendingTransferCall;

  constructor(call: CancelPendingTransferCall) {
    this._call = call;
  }
}

export class ApproveTokenAndCallContractCall extends ethereum.Call {
  get inputs(): ApproveTokenAndCallContractCall__Inputs {
    return new ApproveTokenAndCallContractCall__Inputs(this);
  }

  get outputs(): ApproveTokenAndCallContractCall__Outputs {
    return new ApproveTokenAndCallContractCall__Outputs(this);
  }
}

export class ApproveTokenAndCallContractCall__Inputs {
  _call: ApproveTokenAndCallContractCall;

  constructor(call: ApproveTokenAndCallContractCall) {
    this._call = call;
  }

  get _wallet(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _token(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _spender(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get _amount(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get _contract(): Address {
    return this._call.inputValues[4].value.toAddress();
  }

  get _data(): Bytes {
    return this._call.inputValues[5].value.toBytes();
  }
}

export class ApproveTokenAndCallContractCall__Outputs {
  _call: ApproveTokenAndCallContractCall;

  constructor(call: ApproveTokenAndCallContractCall) {
    this._call = call;
  }
}

export class RemoveFromWhitelistCall extends ethereum.Call {
  get inputs(): RemoveFromWhitelistCall__Inputs {
    return new RemoveFromWhitelistCall__Inputs(this);
  }

  get outputs(): RemoveFromWhitelistCall__Outputs {
    return new RemoveFromWhitelistCall__Outputs(this);
  }
}

export class RemoveFromWhitelistCall__Inputs {
  _call: RemoveFromWhitelistCall;

  constructor(call: RemoveFromWhitelistCall) {
    this._call = call;
  }

  get _wallet(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _target(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class RemoveFromWhitelistCall__Outputs {
  _call: RemoveFromWhitelistCall;

  constructor(call: RemoveFromWhitelistCall) {
    this._call = call;
  }
}

export class CallContractCall extends ethereum.Call {
  get inputs(): CallContractCall__Inputs {
    return new CallContractCall__Inputs(this);
  }

  get outputs(): CallContractCall__Outputs {
    return new CallContractCall__Outputs(this);
  }
}

export class CallContractCall__Inputs {
  _call: CallContractCall;

  constructor(call: CallContractCall) {
    this._call = call;
  }

  get _wallet(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _contract(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _value(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get _data(): Bytes {
    return this._call.inputValues[3].value.toBytes();
  }
}

export class CallContractCall__Outputs {
  _call: CallContractCall;

  constructor(call: CallContractCall) {
    this._call = call;
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get _registry(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _transferStorage(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _guardianStorage(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get _priceProvider(): Address {
    return this._call.inputValues[3].value.toAddress();
  }

  get _securityPeriod(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }

  get _securityWindow(): BigInt {
    return this._call.inputValues[5].value.toBigInt();
  }

  get _defaultLimit(): BigInt {
    return this._call.inputValues[6].value.toBigInt();
  }

  get _oldLimitManager(): Address {
    return this._call.inputValues[7].value.toAddress();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}
